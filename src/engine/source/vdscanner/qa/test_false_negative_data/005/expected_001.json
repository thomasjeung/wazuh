[
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.17.25.1",
        "description": "Issue summary: Processing a maliciously formatted PKCS12 file may lead OpenSSL to crash leading to a potential Denial of Service attack  Impact summary: Applications loading files in the PKCS12 format from untrusted sources might terminate abruptly.  A file in PKCS12 format can contain certificates and keys and may come from an untrusted source. The PKCS12 specification allows certain fields to be NULL, but OpenSSL does not correctly check for this case. This can lead to a NULL pointer dereference that results in OpenSSL crashing. If an application processes PKCS12 files from an untrusted source using the OpenSSL APIs then that application will be vulnerable to this issue.  OpenSSL APIs that are vulnerable to this are: PKCS12_parse(), PKCS12_unpack_p7data(), PKCS12_unpack_p7encdata(), PKCS12_unpack_authsafes() and PKCS12_newpass().  We have also fixed a similar issue in SMIME_write_PKCS7(). However since this function is related to writing data we do not consider it security significant.  The FIPS modules in 3.2, 3.1 and 3.0 are not affected by this issue.",
        "id": "CVE-2024-0727",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.5,
            "version": "3.1"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.17.15.1",
        "description": "Issue summary: Checking excessively long DH keys or parameters may be very slow.  Impact summary: Applications that use the functions DH_check(), DH_check_ex() or EVP_PKEY_param_check() to check a DH key or DH parameters may experience long delays. Where the key or parameters that are being checked have been obtained from an untrusted source this may lead to a Denial of Service.  The function DH_check() performs various checks on DH parameters. After fixing CVE-2023-3446 it was discovered that a large q parameter value can also trigger an overly long computation during some of these checks. A correct q value, if present, cannot be larger than the modulus p parameter, thus it is unnecessary to perform these checks if q is larger than p.  An application that calls DH_check() and supplies a key or parameters obtained from an untrusted source could be vulnerable to a Denial of Service attack.  The function DH_check() is itself called by a number of other OpenSSL functions. An application calling any of those other functions may similarly be affected. The other functions affected by this are DH_check_ex() and EVP_PKEY_param_check().  Also vulnerable are the OpenSSL dhparam and pkeyparam command line applications when using the \"-check\" option.  The OpenSSL SSL/TLS implementation is not affected by this issue.  The OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.",
        "id": "CVE-2023-3817",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.3,
            "version": "3.1"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.17.9.1",
        "description": "Issue summary: Checking excessively long DH keys or parameters may be very slow.  Impact summary: Applications that use the functions DH_check(), DH_check_ex() or EVP_PKEY_param_check() to check a DH key or DH parameters may experience long delays. Where the key or parameters that are being checked have been obtained from an untrusted source this may lead to a Denial of Service.  The function DH_check() performs various checks on DH parameters. One of those checks confirms that the modulus ('p' parameter) is not too large. Trying to use a very large modulus is slow and OpenSSL will not normally use a modulus which is over 10,000 bits in length.  However the DH_check() function checks numerous aspects of the key or parameters that have been supplied. Some of those checks use the supplied modulus value even if it has already been found to be too large.  An application that calls DH_check() and supplies a key or parameters obtained from an untrusted source could be vulernable to a Denial of Service attack.  The function DH_check() is itself called by a number of other OpenSSL functions. An application calling any of those other functions may similarly be affected. The other functions affected by this are DH_check_ex() and EVP_PKEY_param_check().  Also vulnerable are the OpenSSL dhparam and pkeyparam command line applications when using the '-check' option.  The OpenSSL SSL/TLS implementation is not affected by this issue. The OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.",
        "id": "CVE-2023-3446",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.3,
            "version": "3.1"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.17.6.1",
        "description": "Issue summary: Processing some specially crafted ASN.1 object identifiers or data containing them may be very slow.  Impact summary: Applications that use OBJ_obj2txt() directly, or use any of the OpenSSL subsystems OCSP, PKCS7/SMIME, CMS, CMP/CRMF or TS with no message size limit may experience notable to very long delays when processing those messages, which may lead to a Denial of Service.  An OBJECT IDENTIFIER is composed of a series of numbers - sub-identifiers - most of which have no size limit.  OBJ_obj2txt() may be used to translate an ASN.1 OBJECT IDENTIFIER given in DER encoding form (using the OpenSSL type ASN1_OBJECT) to its canonical numeric text form, which are the sub-identifiers of the OBJECT IDENTIFIER in decimal form, separated by periods.  When one of the sub-identifiers in the OBJECT IDENTIFIER is very large (these are sizes that are seen as absurdly large, taking up tens or hundreds of KiBs), the translation to a decimal number in text may take a very long time.  The time complexity is O(n^2) with 'n' being the size of the sub-identifiers in bytes (*).  With OpenSSL 3.0, support to fetch cryptographic algorithms using names / identifiers in string form was introduced.  This includes using OBJECT IDENTIFIERs in canonical numeric text form as identifiers for fetching algorithms.  Such OBJECT IDENTIFIERs may be received through the ASN.1 structure AlgorithmIdentifier, which is commonly used in multiple protocols to specify what cryptographic algorithm should be used to sign or verify, encrypt or decrypt, or digest passed data.  Applications that call OBJ_obj2txt() directly with untrusted data are affected, with any version of OpenSSL.  If the use is for the mere purpose of display, the severity is considered low.  In OpenSSL 3.0 and newer, this affects the subsystems OCSP, PKCS7/SMIME, CMS, CMP/CRMF or TS.  It also impacts anything that processes X.509 certificates, including simple things like verifying its signature.  The impact on TLS is relatively low, because all versions of OpenSSL have a 100KiB limit on the peer's certificate chain.  Additionally, this only impacts clients, or servers that have explicitly enabled client authentication.  In OpenSSL 1.1.1 and 1.0.2, this only affects displaying diverse objects, such as X.509 certificates.  This is assumed to not happen in such a way that it would cause a Denial of Service, so these versions are considered not affected by this issue in such a way that it would be cause for concern, and the severity is therefore considered low.",
        "id": "CVE-2023-2650",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 6.5,
            "version": "3.1"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "Applications that use a non-default option when verifying certificates may be vulnerable to an attack from a malicious CA to circumvent certain checks.  Invalid certificate policies in leaf certificates are silently ignored by OpenSSL and other certificate policy checks are skipped for that certificate. A malicious CA could use this to deliberately assert invalid certificate policies in order to circumvent policy checking on the certificate altogether.  Policy processing is disabled by default but can be enabled by passing the `-policy' argument to the command line utilities or by calling the `X509_VERIFY_PARAM_set1_policies()' function.",
        "id": "CVE-2023-0465",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.3,
            "version": "3.1"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "A security vulnerability has been identified in all supported versions  of OpenSSL related to the verification of X.509 certificate chains that include policy constraints.  Attackers may be able to exploit this vulnerability by creating a malicious certificate chain that triggers exponential use of computational resources, leading to a denial-of-service (DoS) attack on affected systems.  Policy processing is disabled by default but can be enabled by passing the `-policy' argument to the command line utilities or by calling the `X509_VERIFY_PARAM_set1_policies()' function.",
        "id": "CVE-2023-0464",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 7.5,
            "version": "3.1"
        },
        "severity": "High"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "There is a type confusion vulnerability relating to X.400 address processing inside an X.509 GeneralName. X.400 addresses were parsed as an ASN1_STRING but the public structure definition for GENERAL_NAME incorrectly specified the type of the x400Address field as ASN1_TYPE. This field is subsequently interpreted by the OpenSSL function GENERAL_NAME_cmp as an ASN1_TYPE rather than an ASN1_STRING.  When CRL checking is enabled (i.e. the application sets the X509_V_FLAG_CRL_CHECK flag), this vulnerability may allow an attacker to pass arbitrary pointers to a memcmp call, enabling them to read memory contents or enact a denial of service. In most cases, the attack requires the attacker to provide both the certificate chain and CRL, neither of which need to have a valid signature. If the attacker only controls one of these inputs, the other input must already contain an X.400 address as a CRL distribution point, which is uncommon. As such, this vulnerability is most likely to only affect applications which have implemented their own functionality for retrieving CRLs over a network.",
        "id": "CVE-2023-0286",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 7.4,
            "version": "3.1"
        },
        "severity": "High"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.17.6.1",
        "description": "A timing based side channel exists in the OpenSSL RSA Decryption implementation which could be sufficient to recover a plaintext across a network in a Bleichenbacher style attack. To achieve a successful decryption an attacker would have to be able to send a very large number of trial messages for decryption. The vulnerability affects all RSA padding modes: PKCS#1 v1.5, RSA-OEAP and RSASVE.  For example, in a TLS connection, RSA is commonly used by a client to send an encrypted pre-master secret to the server. An attacker that had observed a genuine connection between a client and a server could use this flaw to send trial messages to the server and record the time taken to process them. After a sufficiently large number of messages the attacker could recover the pre-master secret used for the original connection and thus be able to decrypt the application data sent over that connection.",
        "id": "CVE-2022-4304",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.9,
            "version": "3.1"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "AES OCB mode for 32-bit x86 platforms using the AES-NI assembly optimised implementation will not encrypt the entirety of the data under some circumstances. This could reveal sixteen bytes of data that was preexisting in the memory that wasn't written. In the special case of \"in place\" encryption, sixteen bytes of the plaintext would be revealed. Since OpenSSL does not support OCB based cipher suites for TLS and DTLS, they are both unaffected. Fixed in OpenSSL 3.0.5 (Affected 3.0.0-3.0.4). Fixed in OpenSSL 1.1.1q (Affected 1.1.1-1.1.1p).",
        "id": "CVE-2022-2097",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The c_rehash script does not properly sanitise shell metacharacters to prevent command injection. This script is distributed by some operating systems in a manner where it is automatically executed. On such operating systems, an attacker could execute arbitrary commands with the privileges of the script. Use of the c_rehash script is considered obsolete and should be replaced by the OpenSSL rehash command line tool. Fixed in OpenSSL 3.0.3 (Affected 3.0.0,3.0.1,3.0.2). Fixed in OpenSSL 1.1.1o (Affected 1.1.1-1.1.1n). Fixed in OpenSSL 1.0.2ze (Affected 1.0.2-1.0.2zd).",
        "id": "CVE-2022-1292",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 10.0,
            "version": "2.0"
        },
        "severity": "High"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The X509_V_FLAG_X509_STRICT flag enables additional security checks of the certificates present in a certificate chain. It is not set by default. Starting from OpenSSL version 1.1.1h a check to disallow certificates in the chain that have explicitly encoded elliptic curve parameters was added as an additional strict check. An error in the implementation of this check meant that the result of a previous check to confirm that certificates in the chain are valid CA certificates was overwritten. This effectively bypasses the check that non-CA certificates must not be able to issue other certificates. If a \"purpose\" has been configured then there is a subsequent opportunity for checks that the certificate is a valid CA. All of the named \"purpose\" values implemented in libcrypto perform this check. Therefore, where a purpose is set the certificate chain will still be rejected even when the strict flag has been used. A purpose is set by default in libssl client and server certificate verification routines, but it can be overridden or removed by an application. In order to be affected, an application must explicitly set the X509_V_FLAG_X509_STRICT verification flag and either not set a purpose for the certificate verification or, in the case of TLS client or server applications, override the default purpose. OpenSSL versions 1.1.1h and newer are affected by this issue. Users of these versions should upgrade to OpenSSL 1.1.1k. OpenSSL 1.0.2 is not impacted by this issue. Fixed in OpenSSL 1.1.1k (Affected 1.1.1h-1.1.1j).",
        "id": "CVE-2021-3450",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.8,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "In order to decrypt SM2 encrypted data an application is expected to call the API function EVP_PKEY_decrypt(). Typically an application will call this function twice. The first time, on entry, the \"out\" parameter can be NULL and, on exit, the \"outlen\" parameter is populated with the buffer size required to hold the decrypted plaintext. The application can then allocate a sufficiently sized buffer and call EVP_PKEY_decrypt() again, but this time passing a non-NULL value for the \"out\" parameter. A bug in the implementation of the SM2 decryption code means that the calculation of the buffer size required to hold the plaintext returned by the first call to EVP_PKEY_decrypt() can be smaller than the actual size required by the second call. This can lead to a buffer overflow when EVP_PKEY_decrypt() is called by the application a second time with a buffer that is too small. A malicious attacker who is able present SM2 content for decryption to an application could cause attacker chosen data to overflow the buffer by up to a maximum of 62 bytes altering the contents of other data held after the buffer, possibly changing application behaviour or causing the application to crash. The location of the buffer is application dependent but is typically heap allocated. Fixed in OpenSSL 1.1.1l (Affected 1.1.1-1.1.1k).",
        "id": "CVE-2021-3711",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 7.5,
            "version": "2.0"
        },
        "severity": "High"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "An OpenSSL TLS server may crash if sent a maliciously crafted renegotiation ClientHello message from a client. If a TLSv1.2 renegotiation ClientHello omits the signature_algorithms extension (where it was present in the initial ClientHello), but includes a signature_algorithms_cert extension then a NULL pointer dereference will result, leading to a crash and a denial of service attack. A server is only vulnerable if it has TLSv1.2 and renegotiation enabled (which is the default configuration). OpenSSL TLS clients are not impacted by this issue. All OpenSSL 1.1.1 versions are affected by this issue. Users of these versions should upgrade to OpenSSL 1.1.1k. OpenSSL 1.0.2 is not impacted by this issue. Fixed in OpenSSL 1.1.1k (Affected 1.1.1-1.1.1j).",
        "id": "CVE-2021-3449",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 4.3,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "Calls to EVP_CipherUpdate, EVP_EncryptUpdate and EVP_DecryptUpdate may overflow the output length argument in some cases where the input length is close to the maximum permissable length for an integer on the platform. In such cases the return value from the function call will be 1 (indicating success), but the output length value will be negative. This could cause applications to behave incorrectly or crash. OpenSSL versions 1.1.1i and below are affected by this issue. Users of these versions should upgrade to OpenSSL 1.1.1j. OpenSSL versions 1.0.2x and below are affected by this issue. However OpenSSL 1.0.2 is out of support and no longer receiving public updates. Premium support customers of OpenSSL 1.0.2 should upgrade to 1.0.2y. Other users should upgrade to 1.1.1j. Fixed in OpenSSL 1.1.1j (Affected 1.1.1-1.1.1i). Fixed in OpenSSL 1.0.2y (Affected 1.0.2-1.0.2x).",
        "id": "CVE-2021-23840",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The X.509 GeneralName type is a generic type for representing different types of names. One of those name types is known as EDIPartyName. OpenSSL provides a function GENERAL_NAME_cmp which compares different instances of a GENERAL_NAME to see if they are equal or not. This function behaves incorrectly when both GENERAL_NAMEs contain an EDIPARTYNAME. A NULL pointer dereference and a crash may occur leading to a possible denial of service attack. OpenSSL itself uses the GENERAL_NAME_cmp function for two purposes: 1) Comparing CRL distribution point names between an available CRL and a CRL distribution point embedded in an X509 certificate 2) When verifying that a timestamp response token signer matches the timestamp authority name (exposed via the API functions TS_RESP_verify_response and TS_RESP_verify_token) If an attacker can control both items being compared then that attacker could trigger a crash. For example if the attacker can trick a client or server into checking a malicious certificate against a malicious CRL then this may occur. Note that some applications automatically download CRLs based on a URL embedded in a certificate. This checking happens prior to the signatures on the certificate and CRL being verified. OpenSSL's s_server, s_client and verify tools have support for the \"-crl_download\" option which implements automatic CRL downloading and this attack has been demonstrated to work against those tools. Note that an unrelated bug means that affected versions of OpenSSL cannot parse or construct correct encodings of EDIPARTYNAME. However it is possible to construct a malformed EDIPARTYNAME that OpenSSL's parser will accept and hence trigger this attack. All OpenSSL 1.1.1 and 1.0.2 versions are affected by this issue. Other OpenSSL releases are out of support and have not been checked. Fixed in OpenSSL 1.1.1i (Affected 1.1.1-1.1.1h). Fixed in OpenSSL 1.0.2x (Affected 1.0.2-1.0.2w).",
        "id": "CVE-2020-1971",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 4.3,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "In situations where an attacker receives automated notification of the success or failure of a decryption attempt an attacker, after sending a very large number of messages to be decrypted, can recover a CMS/PKCS7 transported encryption key or decrypt any RSA encrypted message that was encrypted with the public RSA key, using a Bleichenbacher padding oracle attack. Applications are not affected if they use a certificate together with the private RSA key to the CMS_decrypt or PKCS7_decrypt functions to select the correct recipient info to decrypt. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c). Fixed in OpenSSL 1.1.0l (Affected 1.1.0-1.1.0k). Fixed in OpenSSL 1.0.2t (Affected 1.0.2-1.0.2s).",
        "id": "CVE-2019-1563",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 4.3,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "There is an overflow bug in the x64_64 Montgomery squaring procedure used in exponentiation with 512-bit moduli. No EC algorithms are affected. Analysis suggests that attacks against 2-prime RSA1024, 3-prime RSA1536, and DSA1024 as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH512 are considered just feasible. However, for an attack the target would have to re-use the DH512 private key, which is not recommended anyway. Also applications directly using the low level API BN_mod_exp may be affected if they use BN_FLG_CONSTTIME. Fixed in OpenSSL 1.1.1e (Affected 1.1.1-1.1.1d). Fixed in OpenSSL 1.0.2u (Affected 1.0.2-1.0.2t).",
        "id": "CVE-2019-1551",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "OpenSSL 1.1.1 introduced a rewritten random number generator (RNG). This was intended to include protection in the event of a fork() system call in order to ensure that the parent and child processes did not share the same RNG state. However this protection was not being used in the default case. A partial mitigation for this issue is that the output from a high precision timer is mixed into the RNG state so the likelihood of a parent and child process sharing state is significantly reduced. If an application already calls OPENSSL_init_crypto() explicitly using OPENSSL_INIT_ATFORK then this problem does not occur at all. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c).",
        "id": "CVE-2019-1549",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "Normally in OpenSSL EC groups always have a co-factor present and this is used in side channel resistant code paths. However, in some cases, it is possible to construct a group using explicit parameters (instead of using a named curve). In those cases it is possible that such a group does not have the cofactor present. This can occur even where all the parameters match a known named curve. If such a curve is used then OpenSSL falls back to non-side channel resistant code paths which may result in full key recovery during an ECDSA signature operation. In order to be vulnerable an attacker would have to have the ability to time the creation of a large number of signatures where explicit parameters with no co-factor present are in use by an application using libcrypto. For the avoidance of doubt libssl is not vulnerable because explicit parameters are never used. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c). Fixed in OpenSSL 1.1.0l (Affected 1.1.0-1.1.0k). Fixed in OpenSSL 1.0.2t (Affected 1.0.2-1.0.2s).",
        "id": "CVE-2019-1547",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 1.9,
            "version": "2.0"
        },
        "severity": "Low"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.17.34.1",
        "description": "Issue summary: Calling the OpenSSL API function SSL_select_next_proto with an empty supported client protocols buffer may cause a crash or memory contents to be sent to the peer.  Impact summary: A buffer overread can have a range of potential consequences such as unexpected application beahviour or a crash. In particular this issue could result in up to 255 bytes of arbitrary private data from memory being sent to the peer leading to a loss of confidentiality. However, only applications that directly call the SSL_select_next_proto function with a 0 length list of supported client protocols are affected by this issue. This would normally never be a valid scenario and is typically not under attacker control but may occur by accident in the case of a configuration or programming error in the calling application.  The OpenSSL API function SSL_select_next_proto is typically used by TLS applications that support ALPN (Application Layer Protocol Negotiation) or NPN (Next Protocol Negotiation). NPN is older, was never standardised and is deprecated in favour of ALPN. We believe that ALPN is significantly more widely deployed than NPN. The SSL_select_next_proto function accepts a list of protocols from the server and a list of protocols from the client and returns the first protocol that appears in the server list that also appears in the client list. In the case of no overlap between the two lists it returns the first item in the client list. In either case it will signal whether an overlap between the two lists was found. In the case where SSL_select_next_proto is called with a zero length client list it fails to notice this condition and returns the memory immediately following the client list pointer (and reports that there was no overlap in the lists).  This function is typically called from a server side application callback for ALPN or a client side application callback for NPN. In the case of ALPN the list of protocols supplied by the client is guaranteed by libssl to never be zero in length. The list of server protocols comes from the application and should never normally be expected to be of zero length. In this case if the SSL_select_next_proto function has been called as expected (with the list supplied by the client passed in the client/client_len parameters), then the application will not be vulnerable to this issue. If the application has accidentally been configured with a zero length server list, and has accidentally passed that zero length server list in the client/client_len parameters, and has additionally failed to correctly handle a \"no overlap\" response (which would normally result in a handshake failure in ALPN) then it will be vulnerable to this problem.  In the case of NPN, the protocol permits the client to opportunistically select a protocol when there is no overlap. OpenSSL returns the first client protocol in the no overlap case in support of this. The list of client protocols comes from the application and should never normally be expected to be of zero length. However if the SSL_select_next_proto function is accidentally called with a client_len of 0 then an invalid memory pointer will be returned instead. If the application uses this output as the opportunistic protocol then the loss of confidentiality will occur.  This issue has been assessed as Low severity because applications are most likely to be vulnerable if they are using NPN instead of ALPN - but NPN is not widely used. It also requires an application configuration or programming error. Finally, this issue would not typically be under attacker control making active exploitation unlikely.  The FIPS modules in 3.3, 3.2, 3.1 and 3.0 are not affected by this issue.  Due to the low severity of this issue we are not issuing new releases of OpenSSL at this time. The fix will be included in the next releases when they become available.",
        "id": "CVE-2024-5535",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 9.1,
            "version": "3.1"
        },
        "severity": "Critical"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "ChaCha20-Poly1305 is an AEAD cipher, and requires a unique nonce input for every encryption operation. RFC 7539 specifies that the nonce value (IV) should be 96 bits (12 bytes). OpenSSL allows a variable nonce length and front pads the nonce with 0 bytes if it is less than 12 bytes. However it also incorrectly allows a nonce to be set of up to 16 bytes. In this case only the last 12 bytes are significant and any additional leading bytes are ignored. It is a requirement of using this cipher that nonce values are unique. Messages encrypted using a reused nonce value are susceptible to serious confidentiality and integrity attacks. If an application changes the default nonce length to be longer than 12 bytes and then makes a change to the leading bytes of the nonce expecting the new value to be a new unique nonce then such an application could inadvertently encrypt messages with a reused nonce. Additionally the ignored bytes in a long nonce are not covered by the integrity guarantee of this cipher. Any application that relies on the integrity of these ignored leading bytes of a long nonce may be further affected. Any OpenSSL internal use of this cipher, including in SSL/TLS, is safe because no such use sets such a long nonce value. However user applications that use this cipher directly and set a non-default nonce length to be longer than 12 bytes may be vulnerable. OpenSSL versions 1.1.1 and 1.1.0 are affected by this issue. Due to the limited scope of affected deployments this has been assessed as low severity and therefore we are not creating new releases at this time. Fixed in OpenSSL 1.1.1c (Affected 1.1.1-1.1.1b). Fixed in OpenSSL 1.1.0k (Affected 1.1.0-1.1.0j).",
        "id": "CVE-2019-1543",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.8,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "Constructed ASN.1 types with a recursive definition (such as can be found in PKCS7) could eventually exceed the stack given malicious input with excessive recursion. This could result in a Denial Of Service attack. There are no such structures used within SSL/TLS that come from untrusted sources so this is considered safe. Fixed in OpenSSL 1.1.0h (Affected 1.1.0-1.1.0g). Fixed in OpenSSL 1.0.2o (Affected 1.0.2b-1.0.2n).",
        "id": "CVE-2018-0739",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 4.3,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The OpenSSL RSA Key generation algorithm has been shown to be vulnerable to a cache timing side channel attack. An attacker with sufficient access to mount cache timing attacks during the RSA key generation process could recover the private key. Fixed in OpenSSL 1.1.0i-dev (Affected 1.1.0-1.1.0h). Fixed in OpenSSL 1.0.2p-dev (Affected 1.0.2b-1.0.2o).",
        "id": "CVE-2018-0737",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 4.3,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The OpenSSL ECDSA signature algorithm has been shown to be vulnerable to a timing side channel attack. An attacker could use variations in the signing algorithm to recover the private key. Fixed in OpenSSL 1.1.0j (Affected 1.1.0-1.1.0i). Fixed in OpenSSL 1.1.1a (Affected 1.1.1).",
        "id": "CVE-2018-0735",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 4.3,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "There is an overflow bug in the AVX2 Montgomery multiplication procedure used in exponentiation with 1024-bit moduli. No EC algorithms are affected. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH1024 are considered just feasible, because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be significant. However, for an attack on TLS to be meaningful, the server would have to share the DH1024 private key among multiple clients, which is no longer an option since CVE-2016-0701. This only affects processors that support the AVX2 but not ADX extensions like Intel Haswell (4th generation). Note: The impact from this issue is similar to CVE-2017-3736, CVE-2017-3732 and CVE-2015-3193. OpenSSL version 1.0.2-1.0.2m and 1.1.0-1.1.0g are affected. Fixed in OpenSSL 1.0.2n. Due to the low severity of this issue we are not issuing a new release of OpenSSL 1.1.0 at this time. The fix will be included in OpenSSL 1.1.0h when it becomes available. The fix is also available in commit e502cc86d in the OpenSSL git repository.",
        "id": "CVE-2017-3738",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 4.3,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "ssl/s3_clnt.c in OpenSSL 1.0.0 before 1.0.0t, 1.0.1 before 1.0.1p, and 1.0.2 before 1.0.2d, when used for a multi-threaded client, writes the PSK identity hint to an incorrect data structure, which allows remote servers to cause a denial of service (race condition and double free) via a crafted ServerKeyExchange message.",
        "id": "CVE-2015-3196",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 4.3,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k does not enforce certain constraints on certificate data, which allows remote attackers to defeat a fingerprint-based certificate-blacklist protection mechanism by including crafted data within a certificate's unsigned portion, related to crypto/asn1/a_verify.c, crypto/dsa/dsa_asn1.c, crypto/ecdsa/ecs_vrf.c, and crypto/x509/x_all.c.",
        "id": "CVE-2014-8275",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The AES-NI implementation in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h does not consider memory allocation during a certain padding check, which allows remote attackers to obtain sensitive cleartext information via a padding-oracle attack against an AES CBC session. NOTE: this vulnerability exists because of an incorrect fix for CVE-2013-0169.",
        "id": "CVE-2016-2107",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 2.6,
            "version": "2.0"
        },
        "severity": "Low"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The ASN1_TFLG_COMBINE implementation in crypto/asn1/tasn_dec.c in OpenSSL before 0.9.8zh, 1.0.0 before 1.0.0t, 1.0.1 before 1.0.1q, and 1.0.2 before 1.0.2e mishandles errors caused by malformed X509_ATTRIBUTE data, which allows remote attackers to obtain sensitive information from process memory by triggering a decoding failure in a PKCS#7 or CMS application.",
        "id": "CVE-2015-3195",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "ASN.1 strings are represented internally within OpenSSL as an ASN1_STRING structure which contains a buffer holding the string data and a field holding the buffer length. This contrasts with normal C strings which are repesented as a buffer for the string data which is terminated with a NUL (0) byte. Although not a strict requirement, ASN.1 strings that are parsed using OpenSSL's own \"d2i\" functions (and other similar parsing functions) as well as any string whose value has been set with the ASN1_STRING_set() function will additionally NUL terminate the byte array in the ASN1_STRING structure. However, it is possible for applications to directly construct valid ASN1_STRING structures which do not NUL terminate the byte array by directly setting the \"data\" and \"length\" fields in the ASN1_STRING array. This can also happen by using the ASN1_STRING_set0() function. Numerous OpenSSL functions that print ASN.1 data have been found to assume that the ASN1_STRING byte array will be NUL terminated, even though this is not guaranteed for strings that have been directly constructed. Where an application requests an ASN.1 structure to be printed, and where that ASN.1 structure contains ASN1_STRINGs that have been directly constructed by the application without NUL terminating the \"data\" field, then a read buffer overrun can occur. The same thing can also occur during name constraints processing of certificates (for example if a certificate has been directly constructed by the application instead of loading it via the OpenSSL parsing functions, and the certificate contains non NUL terminated ASN1_STRING structures). It can also occur in the X509_get1_email(), X509_REQ_get1_email() and X509_get1_ocsp() functions. If a malicious actor can cause an application to directly construct an ASN1_STRING and then process it through one of the affected OpenSSL functions then this issue could be hit. This might result in a crash (causing a Denial of Service attack). It could also result in the disclosure of private memory contents (such as private keys, or sensitive plaintext). Fixed in OpenSSL 1.1.1l (Affected 1.1.1-1.1.1k). Fixed in OpenSSL 1.0.2za (Affected 1.0.2-1.0.2y).",
        "id": "CVE-2021-3712",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.8,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "Memory leak in d1_srtp.c in the DTLS SRTP extension in OpenSSL 1.0.1 before 1.0.1j allows remote attackers to cause a denial of service (memory consumption) via a crafted handshake message.",
        "id": "CVE-2014-3513",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 7.1,
            "version": "2.0"
        },
        "severity": "High"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The DH_check_pub_key function in crypto/dh/dh_check.c in OpenSSL 1.0.2 before 1.0.2f does not ensure that prime numbers are appropriate for Diffie-Hellman (DH) key exchange, which makes it easier for remote attackers to discover a private DH exponent by making multiple handshakes with a peer that chose an inappropriate number, as demonstrated by a number in an X9.42 file.",
        "id": "CVE-2016-0701",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 2.6,
            "version": "2.0"
        },
        "severity": "Low"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "While parsing an IPAddressFamily extension in an X.509 certificate, it is possible to do a one-byte overread. This would result in an incorrect text display of the certificate. This bug has been present since 2006 and is present in all versions of OpenSSL before 1.0.2m and 1.1.0g.",
        "id": "CVE-2017-3735",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The do_free_upto function in crypto/cms/cms_smime.c in OpenSSL before 0.9.8zg, 1.0.0 before 1.0.0s, 1.0.1 before 1.0.1n, and 1.0.2 before 1.0.2b allows remote attackers to cause a denial of service (infinite loop) via vectors that trigger a NULL value of a BIO data structure, as demonstrated by an unrecognized X.660 OID for a hash function.",
        "id": "CVE-2015-1792",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "crypto/rsa/rsa_ameth.c in OpenSSL 1.0.1 before 1.0.1q and 1.0.2 before 1.0.2e allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via an RSA PSS ASN.1 signature that lacks a mask generation function parameter.",
        "id": "CVE-2015-3194",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The Diffie-Hellman Key Agreement Protocol allows remote attackers (from the client side) to send arbitrary numbers that are actually not public keys, and trigger expensive server-side DHE modular-exponentiation calculations, aka a D(HE)at or D(HE)ater attack. The client needs very little CPU resources and network bandwidth. The attack may be more disruptive in cases where a client can require a server to select its largest supported key size. The basic attack scenario is that the client must claim that it can only communicate with DHE, and the server must be configured to allow DHE.",
        "id": "CVE-2002-20001",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "In addition to the c_rehash shell command injection identified in CVE-2022-1292, further circumstances where the c_rehash script does not properly sanitise shell metacharacters to prevent command injection were found by code review. When the CVE-2022-1292 was fixed it was not discovered that there are other places in the script where the file names of certificates being hashed were possibly passed to a command executed through the shell. This script is distributed by some operating systems in a manner where it is automatically executed. On such operating systems, an attacker could execute arbitrary commands with the privileges of the script. Use of the c_rehash script is considered obsolete and should be replaced by the OpenSSL rehash command line tool. Fixed in OpenSSL 3.0.4 (Affected 3.0.0,3.0.1,3.0.2,3.0.3). Fixed in OpenSSL 1.1.1p (Affected 1.1.1-1.1.1o). Fixed in OpenSSL 1.0.2zf (Affected 1.0.2-1.0.2ze).",
        "id": "CVE-2022-2068",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 10.0,
            "version": "2.0"
        },
        "severity": "High"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The ssl23_get_client_hello function in s23_srvr.c in OpenSSL 0.9.8zc, 1.0.0o, and 1.0.1j does not properly handle attempts to use unsupported protocols, which allows remote attackers to cause a denial of service (NULL pointer dereference and daemon crash) via an unexpected handshake, as demonstrated by an SSLv3 handshake to a no-ssl3 application with certain error handling.  NOTE: this issue became relevant after the CVE-2014-3568 fix.",
        "id": "CVE-2014-3569",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "Race condition in the ssl3_get_new_session_ticket function in ssl/s3_clnt.c in OpenSSL before 0.9.8zg, 1.0.0 before 1.0.0s, 1.0.1 before 1.0.1n, and 1.0.2 before 1.0.2b, when used for a multi-threaded client, allows remote attackers to cause a denial of service (double free and application crash) or possibly have unspecified other impact by providing a NewSessionTicket during an attempt to reuse a ticket that had been obtained earlier.",
        "id": "CVE-2015-1791",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 6.8,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "Memory leak in the dtls1_buffer_record function in d1_pkt.c in OpenSSL 1.0.0 before 1.0.0p and 1.0.1 before 1.0.1k allows remote attackers to cause a denial of service (memory consumption) by sending many duplicate records for the next epoch, leading to failure of replay detection.",
        "id": "CVE-2015-0206",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The OpenSSL public API function X509_issuer_and_serial_hash() attempts to create a unique hash value based on the issuer and serial number data contained within an X509 certificate. However it fails to correctly handle any errors that may occur while parsing the issuer field (which might occur if the issuer field is maliciously constructed). This may subsequently result in a NULL pointer deref and a crash leading to a potential denial of service attack. The function X509_issuer_and_serial_hash() is never directly called by OpenSSL itself so applications are only vulnerable if they use this function directly and they use it on certificates that may have been obtained from untrusted sources. OpenSSL versions 1.1.1i and below are affected by this issue. Users of these versions should upgrade to OpenSSL 1.1.1j. OpenSSL versions 1.0.2x and below are affected by this issue. However OpenSSL 1.0.2 is out of support and no longer receiving public updates. Premium support customers of OpenSSL 1.0.2 should upgrade to 1.0.2y. Other users should upgrade to 1.1.1j. Fixed in OpenSSL 1.1.1j (Affected 1.1.1-1.1.1i). Fixed in OpenSSL 1.0.2y (Affected 1.0.2-1.0.2x).",
        "id": "CVE-2021-23841",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 4.3,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "Use-after-free vulnerability in the d2i_ECPrivateKey function in crypto/ec/ec_asn1.c in OpenSSL before 0.9.8zf, 1.0.0 before 1.0.0r, 1.0.1 before 1.0.1m, and 1.0.2 before 1.0.2a might allow remote attackers to cause a denial of service (memory corruption and application crash) or possibly have unspecified other impact via a malformed Elliptic Curve (EC) private-key file that is improperly handled during import.",
        "id": "CVE-2015-0209",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 6.8,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The PKCS#7 implementation in OpenSSL before 0.9.8zf, 1.0.0 before 1.0.0r, 1.0.1 before 1.0.1m, and 1.0.2 before 1.0.2a does not properly handle a lack of outer ContentInfo, which allows attackers to cause a denial of service (NULL pointer dereference and application crash) by leveraging an application that processes arbitrary PKCS#7 data and providing malformed data with ASN.1 encoding, related to crypto/pkcs7/pk7_doit.c and crypto/pkcs7/pk7_lib.c.",
        "id": "CVE-2015-0289",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The X509_cmp_time function in crypto/x509/x509_vfy.c in OpenSSL before 0.9.8zg, 1.0.0 before 1.0.0s, 1.0.1 before 1.0.1n, and 1.0.2 before 1.0.2b allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted length field in ASN1_TIME data, as demonstrated by an attack against a server that supports client authentication with a custom verification callback.",
        "id": "CVE-2015-1789",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 4.3,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.17.22.1",
        "description": "Issue summary: Generating excessively long X9.42 DH keys or checking excessively long X9.42 DH keys or parameters may be very slow.  Impact summary: Applications that use the functions DH_generate_key() to generate an X9.42 DH key may experience long delays.  Likewise, applications that use DH_check_pub_key(), DH_check_pub_key_ex() or EVP_PKEY_public_check() to check an X9.42 DH key or X9.42 DH parameters may experience long delays. Where the key or parameters that are being checked have been obtained from an untrusted source this may lead to a Denial of Service.  While DH_check() performs all the necessary checks (as of CVE-2023-3817), DH_check_pub_key() doesn't make any of these checks, and is therefore vulnerable for excessively large P and Q parameters.  Likewise, while DH_generate_key() performs a check for an excessively large P, it doesn't check for an excessively large Q.  An application that calls DH_generate_key() or DH_check_pub_key() and supplies a key or parameters obtained from an untrusted source could be vulnerable to a Denial of Service attack.  DH_generate_key() and DH_check_pub_key() are also called by a number of other OpenSSL functions.  An application calling any of those other functions may similarly be affected.  The other functions affected by this are DH_check_pub_key_ex(), EVP_PKEY_public_check(), and EVP_PKEY_generate().  Also vulnerable are the OpenSSL pkey command line application when using the \"-pubcheck\" option, as well as the OpenSSL genpkey command line application.  The OpenSSL SSL/TLS implementation is not affected by this issue.  The OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.",
        "id": "CVE-2023-5678",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.3,
            "version": "3.1"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "Integer overflow in the EVP_EncryptUpdate function in crypto/evp/evp_enc.c in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to cause a denial of service (heap memory corruption) via a large amount of data.",
        "id": "CVE-2016-2106",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The BN_sqr implementation in OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k does not properly calculate the square of a BIGNUM value, which might make it easier for remote attackers to defeat cryptographic protection mechanisms via unspecified vectors, related to crypto/bn/asm/mips.pl, crypto/bn/asm/x86_64-gcc.c, and crypto/bn/bn_asm.c.",
        "id": "CVE-2014-3570",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The asn1_d2i_read_bio function in crypto/asn1/a_d2i_fp.c in the ASN.1 BIO implementation in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to cause a denial of service (memory consumption) via a short invalid encoding.",
        "id": "CVE-2016-2109",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 7.8,
            "version": "2.0"
        },
        "severity": "High"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The ssl3_get_key_exchange function in ssl/s3_clnt.c in OpenSSL 1.0.2 before 1.0.2e allows remote servers to cause a denial of service (segmentation fault) via a zero p value in an anonymous Diffie-Hellman (DH) ServerKeyExchange message.",
        "id": "CVE-2015-1794",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The Anti-Replay feature in the DTLS implementation in OpenSSL before 1.1.0 mishandles early use of a new epoch number in conjunction with a large sequence number, which allows remote attackers to cause a denial of service (false-positive packet drops) via spoofed DTLS records, related to rec_layer_d1.c and ssl3_record.c.",
        "id": "CVE-2016-2181",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The tls_decrypt_ticket function in ssl/t1_lib.c in OpenSSL before 1.1.0 does not consider the HMAC size during validation of the ticket length, which allows remote attackers to cause a denial of service via a ticket that is too short.",
        "id": "CVE-2016-6302",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The X509_to_X509_REQ function in crypto/x509/x509_req.c in OpenSSL before 0.9.8zf, 1.0.0 before 1.0.0r, 1.0.1 before 1.0.1m, and 1.0.2 before 1.0.2a might allow attackers to cause a denial of service (NULL pointer dereference and application crash) via an invalid certificate key.",
        "id": "CVE-2015-0288",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "A timing attack flaw was found in OpenSSL 1.0.1u and before that could allow a malicious user with local access to recover ECDSA P-256 private keys.",
        "id": "CVE-2016-7056",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 2.1,
            "version": "2.0"
        },
        "severity": "Low"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The X509_verify_cert function in crypto/x509/x509_vfy.c in OpenSSL 1.0.1n, 1.0.1o, 1.0.2b, and 1.0.2c does not properly process X.509 Basic Constraints cA values during identification of alternative certificate chains, which allows remote attackers to spoof a Certification Authority role and trigger unintended certificate verifications via a valid leaf certificate.",
        "id": "CVE-2015-1793",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 6.4,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The ASN1_item_ex_d2i function in crypto/asn1/tasn_dec.c in OpenSSL before 0.9.8zf, 1.0.0 before 1.0.0r, 1.0.1 before 1.0.1m, and 1.0.2 before 1.0.2a does not reinitialize CHOICE and ADB data structures, which might allow attackers to cause a denial of service (invalid write operation and memory corruption) by leveraging an application that relies on ASN.1 structure reuse.",
        "id": "CVE-2015-0287",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "Server or client applications that call the SSL_check_chain() function during or after a TLS 1.3 handshake may crash due to a NULL pointer dereference as a result of incorrect handling of the \"signature_algorithms_cert\" TLS extension. The crash occurs if an invalid or unrecognised signature algorithm is received from the peer. This could be exploited by a malicious peer in a Denial of Service attack. OpenSSL version 1.1.1d, 1.1.1e, and 1.1.1f are affected by this issue. This issue did not affect OpenSSL versions prior to 1.1.1d. Fixed in OpenSSL 1.1.1g (Affected 1.1.1d-1.1.1f).",
        "id": "CVE-2020-1967",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The certificate parser in OpenSSL before 1.0.1u and 1.0.2 before 1.0.2i might allow remote attackers to cause a denial of service (out-of-bounds read) via crafted certificate operations, related to s3_clnt.c and s3_srvr.c.",
        "id": "CVE-2016-6306",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 4.3,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "If an SSL/TLS server or client is running on a 32-bit host, and a specific cipher is being used, then a truncated packet can cause that server or client to perform an out-of-bounds read, usually resulting in a crash. For OpenSSL 1.1.0, the crash can be triggered when using CHACHA20/POLY1305; users should upgrade to 1.1.0d. For Openssl 1.0.2, the crash can be triggered when using RC4-MD5; users who have not disabled that algorithm should update to 1.0.2k.",
        "id": "CVE-2017-3731",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The DTLS implementation in OpenSSL before 1.1.0 does not properly restrict the lifetime of queue entries associated with unused out-of-order messages, which allows remote attackers to cause a denial of service (memory consumption) by maintaining many crafted DTLS sessions simultaneously, related to d1_lib.c, statem_dtls.c, statem_lib.c, and statem_srvr.c.",
        "id": "CVE-2016-2179",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "OpenSSL before 0.9.8zc, 1.0.0 before 1.0.0o, and 1.0.1 before 1.0.1j does not properly enforce the no-ssl3 build option, which allows remote attackers to bypass intended access restrictions via an SSL 3.0 handshake, related to s23_clnt.c and s23_srvr.c.",
        "id": "CVE-2014-3568",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 4.3,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "Memory leak in the SRP_VBASE_get_by_user implementation in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory consumption) by providing an invalid username in a connection attempt, related to apps/s_server.c and crypto/srp/srp_vfy.c.",
        "id": "CVE-2016-0798",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 7.8,
            "version": "2.0"
        },
        "severity": "High"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted DTLS message that is processed with a different read operation for the handshake header than for the handshake body, related to the dtls1_get_record function in d1_pkt.c and the ssl3_read_n function in s3_pkt.c.",
        "id": "CVE-2014-3571",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The SSLv2 implementation in OpenSSL before 0.9.8zf, 1.0.0 before 1.0.0r, 1.0.1 before 1.0.1m, and 1.0.2 before 1.0.2a allows remote attackers to cause a denial of service (s2_lib.c assertion failure and daemon exit) via a crafted CLIENT-MASTER-KEY message.",
        "id": "CVE-2015-0293",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The TS_OBJ_print_bio function in crypto/ts/ts_lib.c in the X.509 Public Key Infrastructure Time-Stamp Protocol (TSP) implementation in OpenSSL through 1.0.2h allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted time-stamp file that is mishandled by the \"openssl ts\" command.",
        "id": "CVE-2016-2180",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The Montgomery squaring implementation in crypto/bn/asm/x86_64-mont5.pl in OpenSSL 1.0.2 before 1.0.2e on the x86_64 platform, as used by the BN_mod_exp function, mishandles carry propagation and produces incorrect output, which makes it easier for remote attackers to obtain sensitive private-key information via an attack against use of a (1) Diffie-Hellman (DH) or (2) Diffie-Hellman Ephemeral (DHE) ciphersuite.",
        "id": "CVE-2015-3193",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "Multiple integer overflows in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allow remote attackers to cause a denial of service (heap memory corruption or NULL pointer dereference) or possibly have unspecified other impact via a long digit string that is mishandled by the (1) BN_dec2bn or (2) BN_hex2bn function, related to crypto/bn/bn.h and crypto/bn/bn_print.c.",
        "id": "CVE-2016-0797",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "During key agreement in a TLS handshake using a DH(E) based ciphersuite a malicious server can send a very large prime value to the client. This will cause the client to spend an unreasonably long period of time generating a key for this prime resulting in a hang until the client has finished. This could be exploited in a Denial Of Service attack. Fixed in OpenSSL 1.1.0i-dev (Affected 1.1.0-1.1.0h). Fixed in OpenSSL 1.0.2p-dev (Affected 1.0.2-1.0.2o).",
        "id": "CVE-2018-0732",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "ssl/s2_srvr.c in OpenSSL 1.0.1 before 1.0.1r and 1.0.2 before 1.0.2f does not prevent use of disabled ciphers, which makes it easier for man-in-the-middle attackers to defeat cryptographic protection mechanisms by performing computations on SSLv2 traffic, related to the get_client_master_key and get_client_hello functions.",
        "id": "CVE-2015-3197",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 4.3,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The MOD_EXP_CTIME_COPY_FROM_PREBUF function in crypto/bn/bn_exp.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g does not properly consider cache-bank access times during modular exponentiation, which makes it easier for local users to discover RSA keys by running a crafted application on the same Intel Sandy Bridge CPU core as a victim and leveraging cache-bank conflicts, aka a \"CacheBleed\" attack.",
        "id": "CVE-2016-0702",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 1.9,
            "version": "2.0"
        },
        "severity": "Low"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "Double free vulnerability in the dsa_priv_decode function in crypto/dsa/dsa_ameth.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a malformed DSA private key.",
        "id": "CVE-2016-0705",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 10.0,
            "version": "2.0"
        },
        "severity": "High"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "crypto/x509/x509_vfy.c in OpenSSL 1.0.2i allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) by triggering a CRL operation.",
        "id": "CVE-2016-7052",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The OpenSSL DSA signature algorithm has been shown to be vulnerable to a timing side channel attack. An attacker could use variations in the signing algorithm to recover the private key. Fixed in OpenSSL 1.1.1a (Affected 1.1.1). Fixed in OpenSSL 1.1.0j (Affected 1.1.0-1.1.0i). Fixed in OpenSSL 1.0.2q (Affected 1.0.2-1.0.2p).",
        "id": "CVE-2018-0734",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 4.3,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The PKCS7_dataDecodefunction in crypto/pkcs7/pk7_doit.c in OpenSSL before 0.9.8zg, 1.0.0 before 1.0.0s, 1.0.1 before 1.0.1n, and 1.0.2 before 1.0.2b allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a PKCS#7 blob that uses ASN.1 encoding and lacks inner EncryptedContent data.",
        "id": "CVE-2015-1790",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The SSLv2 protocol, as used in OpenSSL before 1.0.1s and 1.0.2 before 1.0.2g and other products, requires a server to send a ServerVerify message before establishing that a client possesses certain plaintext RSA data, which makes it easier for remote attackers to decrypt TLS ciphertext data by leveraging a Bleichenbacher RSA padding oracle, aka a \"DROWN\" attack.",
        "id": "CVE-2016-0800",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 4.3,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The BN_mod_sqrt() function, which computes a modular square root, contains a bug that can cause it to loop forever for non-prime moduli. Internally this function is used when parsing certificates that contain elliptic curve public keys in compressed form or explicit elliptic curve parameters with a base point encoded in compressed form. It is possible to trigger the infinite loop by crafting a certificate that has invalid explicit curve parameters. Since certificate parsing happens prior to verification of the certificate signature, any process that parses an externally supplied certificate may thus be subject to a denial of service attack. The infinite loop can also be reached when parsing crafted private keys as they can contain explicit elliptic curve parameters. Thus vulnerable situations include: - TLS clients consuming server certificates - TLS servers consuming client certificates - Hosting providers taking certificates or private keys from customers - Certificate authorities parsing certification requests from subscribers - Anything else which parses ASN.1 elliptic curve parameters Also any other applications that use the BN_mod_sqrt() where the attacker can control the parameter values are vulnerable to this DoS issue. In the OpenSSL 1.0.2 version the public key is not parsed during initial parsing of the certificate which makes it slightly harder to trigger the infinite loop. However any operation which requires the public key from the certificate will trigger the infinite loop. In particular the attacker can use a self-signed certificate to trigger the loop during verification of the certificate signature. This issue affects OpenSSL versions 1.0.2, 1.1.1 and 3.0. It was addressed in the releases of 1.1.1n and 3.0.2 on the 15th March 2022. Fixed in OpenSSL 3.0.2 (Affected 3.0.0,3.0.1). Fixed in OpenSSL 1.1.1n (Affected 1.1.1-1.1.1m). Fixed in OpenSSL 1.0.2zd (Affected 1.0.2-1.0.2zc).",
        "id": "CVE-2022-0778",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "Integer overflow in the EVP_EncodeUpdate function in crypto/evp/encode.c in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to cause a denial of service (heap memory corruption) via a large amount of binary data.",
        "id": "CVE-2016-2105",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The X509_NAME_oneline function in crypto/x509/x509_obj.c in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to obtain sensitive information from process stack memory or cause a denial of service (buffer over-read) via crafted EBCDIC ASN.1 data.",
        "id": "CVE-2016-2176",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 6.4,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The BN_GF2m_mod_inv function in crypto/bn/bn_gf2m.c in OpenSSL before 0.9.8s, 1.0.0 before 1.0.0e, 1.0.1 before 1.0.1n, and 1.0.2 before 1.0.2b does not properly handle ECParameters structures in which the curve is over a malformed binary polynomial field, which allows remote attackers to cause a denial of service (infinite loop) via a session that uses an Elliptic Curve algorithm, as demonstrated by an attack against a server that supports client authentication.",
        "id": "CVE-2015-1788",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 4.3,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "Memory leak in the tls_decrypt_ticket function in t1_lib.c in OpenSSL before 0.9.8zc, 1.0.0 before 1.0.0o, and 1.0.1 before 1.0.1j allows remote attackers to cause a denial of service (memory consumption) via a crafted session ticket that triggers an integrity-check failure.",
        "id": "CVE-2014-3567",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 7.1,
            "version": "2.0"
        },
        "severity": "High"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "OpenSSL through 1.0.2h incorrectly uses pointer arithmetic for heap-buffer boundary checks, which might allow remote attackers to cause a denial of service (integer overflow and application crash) or possibly have unspecified other impact by leveraging unexpected malloc behavior, related to s3_srvr.c, ssl_sess.c, and t1_lib.c.",
        "id": "CVE-2016-2177",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 7.5,
            "version": "2.0"
        },
        "severity": "High"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The ASN1_TYPE_cmp function in crypto/asn1/a_type.c in OpenSSL before 0.9.8zf, 1.0.0 before 1.0.0r, 1.0.1 before 1.0.1m, and 1.0.2 before 1.0.2a does not properly perform boolean-type comparisons, which allows remote attackers to cause a denial of service (invalid read operation and application crash) via a crafted X.509 certificate to an endpoint that uses the certificate-verification feature.",
        "id": "CVE-2015-0286",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The ssl3_get_cert_verify function in s3_srvr.c in OpenSSL 1.0.0 before 1.0.0p and 1.0.1 before 1.0.1k accepts client authentication with a Diffie-Hellman (DH) certificate without requiring a CertificateVerify message, which allows remote attackers to obtain access without knowledge of a private key via crafted TLS Handshake Protocol traffic to a server that recognizes a Certification Authority with DH support.",
        "id": "CVE-2015-0205",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The dsa_sign_setup function in crypto/dsa/dsa_ossl.c in OpenSSL through 1.0.2h does not properly ensure the use of constant-time operations, which makes it easier for local users to discover a DSA private key via a timing side-channel attack.",
        "id": "CVE-2016-2178",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 2.1,
            "version": "2.0"
        },
        "severity": "Low"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "There is a carry propagating bug in the Broadwell-specific Montgomery multiplication procedure in OpenSSL 1.0.2 and 1.1.0 before 1.1.0c that handles input lengths divisible by, but longer than 256 bits. Analysis suggests that attacks against RSA, DSA and DH private keys are impossible. This is because the subroutine in question is not used in operations with the private key itself and an input of the attacker's direct choice. Otherwise the bug can manifest itself as transient authentication and key negotiation failures or reproducible erroneous outcome of public-key operations with specially crafted input. Among EC algorithms only Brainpool P-512 curves are affected and one presumably can attack ECDH key negotiation. Impact was not analyzed in detail, because pre-requisites for attack are considered unlikely. Namely multiple clients have to choose the curve in question and the server has to share the private key among them, neither of which is default behaviour. Even then only clients that chose the curve will be affected.",
        "id": "CVE-2016-7055",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 2.6,
            "version": "2.0"
        },
        "severity": "Low"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The ssl3_get_key_exchange function in s3_clnt.c in OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k allows remote SSL servers to conduct RSA-to-EXPORT_RSA downgrade attacks and facilitate brute-force decryption by offering a weak ephemeral RSA key in a noncompliant role, related to the \"FREAK\" issue.  NOTE: the scope of this CVE is only client code based on OpenSSL, not EXPORT_RSA issues associated with servers or other TLS implementations.",
        "id": "CVE-2015-0204",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 4.3,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The BN_bn2dec function in crypto/bn/bn_print.c in OpenSSL before 1.1.0 does not properly validate division results, which allows remote attackers to cause a denial of service (out-of-bounds write and application crash) or possibly have unspecified other impact via unknown vectors.",
        "id": "CVE-2016-2182",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 7.5,
            "version": "2.0"
        },
        "severity": "High"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The DES and Triple DES ciphers, as used in the TLS, SSH, and IPSec protocols and other protocols and products, have a birthday bound of approximately four billion blocks, which makes it easier for remote attackers to obtain cleartext data via a birthday attack against a long-duration encrypted session, as demonstrated by an HTTPS session using Triple DES in CBC mode, aka a \"Sweet32\" attack.",
        "id": "CVE-2016-2183",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "Integer overflow in the MDC2_Update function in crypto/mdc2/mdc2dgst.c in OpenSSL before 1.1.0 allows remote attackers to cause a denial of service (out-of-bounds write and application crash) or possibly have unspecified other impact via unknown vectors.",
        "id": "CVE-2016-6303",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 7.5,
            "version": "2.0"
        },
        "severity": "High"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The function X509_VERIFY_PARAM_add0_policy() is documented to implicitly enable the certificate policy check when doing certificate verification. However the implementation of the function does not enable the check which allows certificates with invalid or incorrect policies to pass the certificate verification.  As suddenly enabling the policy check could break existing deployments it was decided to keep the existing behavior of the X509_VERIFY_PARAM_add0_policy() function.  Instead the applications that require OpenSSL to perform certificate policy check need to use X509_VERIFY_PARAM_set1_policies() or explicitly enable the policy check by calling X509_VERIFY_PARAM_set_flags() with the X509_V_FLAG_POLICY_CHECK flag argument.  Certificate policy checks are disabled by default in OpenSSL and are not commonly used by applications.",
        "id": "CVE-2023-0466",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.3,
            "version": "3.1"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The public API function BIO_new_NDEF is a helper function used for streaming ASN.1 data via a BIO. It is primarily used internally to OpenSSL to support the SMIME, CMS and PKCS7 streaming capabilities, but may also be called directly by end user applications.  The function receives a BIO from the caller, prepends a new BIO_f_asn1 filter BIO onto the front of it to form a BIO chain, and then returns the new head of the BIO chain to the caller. Under certain conditions, for example if a CMS recipient public key is invalid, the new filter BIO is freed and the function returns a NULL result indicating a failure. However, in this case, the BIO chain is not properly cleaned up and the BIO passed by the caller still retains internal pointers to the previously freed filter BIO. If the caller then goes on to call BIO_pop() on the BIO then a use-after-free will occur. This will most likely result in a crash.    This scenario occurs directly in the internal function B64_write_ASN1() which may cause BIO_new_NDEF() to be called and will subsequently call BIO_pop() on the BIO. This internal function is in turn called by the public API functions PEM_write_bio_ASN1_stream, PEM_write_bio_CMS_stream, PEM_write_bio_PKCS7_stream, SMIME_write_ASN1, SMIME_write_CMS and SMIME_write_PKCS7.  Other public API functions that may be impacted by this include i2d_ASN1_bio_stream, BIO_new_CMS, BIO_new_PKCS7, i2d_CMS_bio_stream and i2d_PKCS7_bio_stream.  The OpenSSL cms and smime command line applications are similarly affected.",
        "id": "CVE-2023-0215",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 7.5,
            "version": "3.1"
        },
        "severity": "High"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The function PEM_read_bio_ex() reads a PEM file from a BIO and parses and decodes the \"name\" (e.g. \"CERTIFICATE\"), any header data and the payload data. If the function succeeds then the \"name_out\", \"header\" and \"data\" arguments are populated with pointers to buffers containing the relevant decoded data. The caller is responsible for freeing those buffers. It is possible to construct a PEM file that results in 0 bytes of payload data. In this case PEM_read_bio_ex() will return a failure code but will populate the header argument with a pointer to a buffer that has already been freed. If the caller also frees this buffer then a double free will occur. This will most likely lead to a crash. This could be exploited by an attacker who has the ability to supply malicious PEM files for parsing to achieve a denial of service attack.  The functions PEM_read_bio() and PEM_read() are simple wrappers around PEM_read_bio_ex() and therefore these functions are also directly affected.  These functions are also called indirectly by a number of other OpenSSL functions including PEM_X509_INFO_read_bio_ex() and SSL_CTX_use_serverinfo_file() which are also vulnerable. Some OpenSSL internal uses of these functions are not vulnerable because the caller does not free the header argument if PEM_read_bio_ex() returns a failure code. These locations include the PEM_read_bio_TYPE() functions as well as the decoders introduced in OpenSSL 3.0.  The OpenSSL asn1parse command line application is also impacted by this issue.",
        "id": "CVE-2022-4450",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 7.5,
            "version": "3.1"
        },
        "severity": "High"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "Multiple memory leaks in t1_lib.c in OpenSSL before 1.0.1u, 1.0.2 before 1.0.2i, and 1.1.0 before 1.1.0a allow remote attackers to cause a denial of service (memory consumption) via large OCSP Status Request extensions.",
        "id": "CVE-2016-6304",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 7.8,
            "version": "2.0"
        },
        "severity": "High"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "There is a carry propagating bug in the x86_64 Montgomery squaring procedure in OpenSSL 1.0.2 before 1.0.2k and 1.1.0 before 1.1.0d. No EC algorithms are affected. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH are considered just feasible (although very difficult) because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be very significant and likely only accessible to a limited number of attackers. An attacker would additionally need online access to an unpatched system using the target private key in a scenario with persistent DH parameters and a private key that is shared between multiple clients. For example this can occur by default in OpenSSL DHE based SSL/TLS ciphersuites. Note: This issue is very similar to CVE-2015-3193 but must be treated as a separate problem.",
        "id": "CVE-2017-3732",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 4.3,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.17.28.2",
        "description": "Issue summary: Some non-default TLS server configurations can cause unbounded memory growth when processing TLSv1.3 sessions  Impact summary: An attacker may exploit certain server configurations to trigger unbounded memory growth that would lead to a Denial of Service  This problem can occur in TLSv1.3 if the non-default SSL_OP_NO_TICKET option is being used (but not if early_data support is also configured and the default anti-replay protection is in use). In this case, under certain conditions, the session cache can get into an incorrect state and it will fail to flush properly as it fills. The session cache will continue to grow in an unbounded manner. A malicious client could deliberately create the scenario for this failure to force a Denial of Service. It may also happen by accident in normal operation.  This issue only affects TLS servers supporting TLSv1.3. It does not affect TLS clients.  The FIPS modules in 3.2, 3.1 and 3.0 are not affected by this issue. OpenSSL 1.0.2 is also not affected by this issue.",
        "id": "CVE-2024-2511",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 0.0,
            "version": ""
        },
        "severity": ""
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "The ssl3_get_key_exchange function in s3_clnt.c in OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k allows remote SSL servers to conduct ECDHE-to-ECDH downgrade attacks and trigger a loss of forward secrecy by omitting the ServerKeyExchange message.",
        "id": "CVE-2014-3572",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 5.0,
            "version": "2.0"
        },
        "severity": "Medium"
    },
    {
        "category": "Packages",
        "condition": "Package less than 0:1.1.1l-150500.15.4",
        "description": "There is a carry propagating bug in the x86_64 Montgomery squaring procedure in OpenSSL before 1.0.2m and 1.1.0 before 1.1.0g. No EC algorithms are affected. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH are considered just feasible (although very difficult) because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be very significant and likely only accessible to a limited number of attackers. An attacker would additionally need online access to an unpatched system using the target private key in a scenario with persistent DH parameters and a private key that is shared between multiple clients. This only affects processors that support the BMI1, BMI2 and ADX extensions like Intel Broadwell (5th generation) and later or AMD Ryzen.",
        "id": "CVE-2017-3736",
        "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
        "score": {
            "base": 4.0,
            "version": "2.0"
        },
        "severity": "Medium"
    }
]
